/*
 * Generated by erpcgen {$erpcgenVersion} on {$todaysDate}.
 *
 * AUTOGENERATED - DO NOT EDIT
 */

{# ---------------- constantsDefinitions ---------------- #}
{% def constantsDefinitions(consts) %}
{% if not empty(consts) %}

// Constant variable definitions
{%  for c in consts %}
const {$c.typeAndName} = {$c.value};
{%  endfor -- consts %}
{% endif %}
{% enddef -- constantsDefinitions %}

{# ---------------- structDeserialHeader ---------------- #}
{% def structDeserialHeader(structs) %}
{% if structs %}
{%  for st in structs %}

//! @brief Function to read struct {$st.name}
static int32_t read_{$st.name}_struct(erpc::Codec * in, {$st.name} * data);
{%  endfor -- structs %}
{% endif %}
{% enddef -- structDeserialHeader %}

{# ---------------- structSerialHeader ---------------- #}
{% def structSerialHeader(structs) %}
{% if structs %}
{%  for st in structs %}

//! @brief Function to write struct {$st.name}
{#int32_t write_{$st.name}_struct(erpc::Codec * out, const {$st.name} * data{% if st.isNeedIfDealloc %}, bool needDealloc{% endif %});#}
static int32_t write_{$st.name}_struct(erpc::Codec * out, const {$st.name} * data);
{%  endfor -- structs %}
{% endif %}
{% enddef  -- structSerialHeader %}

{# ---------------- structDeserialSource ---------------- #}
{% def structDeserialSource(structs) %}
{% if structs %}
{%  for st in structs %}

// Read struct {$st.name} function implementation
static int32_t read_{$st.name}_struct(erpc::Codec * in, {$st.name} * data)
{
{%   if st.hasNullableMember %}
    bool isNull;
{%   endif -- hasNullableMember %}
{%   if st.genStructWrapperF %}
{%    if st.needEnumTmp %}
    int32_t enum_tmp_local;
{%    endif %}
    {% if errVar != ""  %}status_t {$errVar}{% endif %}in->startReadStruct();
{%   else %}
    {% if errVar != ""  %}status_t {$errVar}{% endif %}kErpcStatus_Success;
{%   endif %}
{%   for mem in st.members %}
{%    if mem.isNullable %}
{$> addInfraErrorChecksBegin("    ")}
{$infraErrIndents}    {$infraErrVar}in->readNullFlag(&isNull);
{$infraErrIndents}    if (!isNull)
{$infraErrIndents}    {
{$addIndent(infraErrIndents & "        ", addInfraErrorChecks(mem.coderCall, "decode"))}{$loop.addNewLineIfNotLast}
{$infraErrIndents}    }
{$infraErrIndents}    else
{$infraErrIndents}     {
{$infraErrIndents}        {$mem.coderCall.name}{$mem.structElements} = NULL;
{$infraErrIndents}        {$mem.coderCall.name}{$mem.structElementsCount} = 0;
{$infraErrIndents}    }
{$> addInfraErrorChecksEnd("    ") }
{%    else -- notNullable %}
{$addIndent("    ", addInfraErrorChecks(mem.coderCall, "decode"))}{$loop.addNewLineIfNotLast}
{%    endif -- notNullable %}
{%   endfor -- st.members %}
{%   if st.genStructWrapperF %}
{$> addInfraErrorChecksBegin("    ") }
{$infraErrIndents}    {$infraErrVar}in->endReadStruct();
{$> addInfraErrorChecksEnd("    ") }
{%   endif %}
{% if errVar != ""  %}
    return err;
{% else %}
    return kErpcStatus_Success;
{% endif %}
}
{%  endfor -- structs %}
{% endif %}
{% enddef -- structDeserialSource %}

{# ---------------- structSerialSource ---------------- #}
{% def structSerialSource(structs) %}
{% if structs %}
{%  for st in structs %}

// Write struct {$st.name} function implementation
{#int32_t write_{$st.name}_struct(erpc::Codec * out, const {$st.name} * data{% if st.isNeedIfDealloc %}, bool needDealloc{% endif %})#}
static int32_t write_{$st.name}_struct(erpc::Codec * out, const {$st.name} * data)
{
{%   if st.genStructWrapperF %}
    {% if errVar != ""  %}status_t {$errVar}{% endif %}out->startWriteStruct();
{%   else %}
    {% if errVar != ""  %}status_t {$errVar}{% endif %}kErpcStatus_Success;
{%   endif %}
{%   for mem in st.members %}
{%    if mem.isNullable %}
{$> addInfraErrorChecksBegin("    ") }
{$infraErrIndents}    if ({$mem.coderCall.name}{$mem.structElements} == NULL)
{$infraErrIndents}    {
{$infraErrIndents}        {$infraErrVar}out->writeNullFlag(true);
{$infraErrIndents}    }
{$infraErrIndents}    else
{$infraErrIndents}    {
{$infraErrIndents}        {$infraErrVar}out->writeNullFlag(false);
{$addIndent(infraErrIndents & "        ", addInfraErrorChecks(mem.coderCall, "encode"))}{$loop.addNewLineIfNotLast}
{$infraErrIndents}    }
{$> addInfraErrorChecksEnd("    ") }
{%    else -- notNullable %}
{$addIndent("    ", addInfraErrorChecks(mem.coderCall, "encode"))}{$loop.addNewLineIfNotLast}
{%    endif -- notNullable %}
{%   endfor -- st.members %}
{%   if st.genStructWrapperF %}
{$> addInfraErrorChecksBegin("    ") }
{$infraErrIndents}    {$infraErrVar}out->endWriteStruct();
{$> addInfraErrorChecksEnd("    ") }
{%   endif %}
{% if errVar != ""  %}
    return err;
{% else %}
    return kErpcStatus_Success;
{% endif %}
}
{%  endfor -- structs %}
{% endif %}
{% enddef -- structSerialSource %}

{# ---------------- structFreeSpaceHeader ---------------- #}
{% def structFreeSpaceHeader(structs) %}
{% if structs %}
{%  for st in structs %}

//! @brief Function to free space allocated inside struct {$st.name}
static void free_{$st.name}_struct({$st.name} * data);
{%  endfor -- structs %}
{% endif %}
{% enddef  -- structDeSerialHeader %}

{# ---------------- structFreeSpaceSource ---------------- #}
{% def structFreeSpaceSource(structs) %}
{% if structs %}
{%  for st in structs %}

// Free space allocated inside struct {$st.name} function implementation
static void free_{$st.name}_struct({$st.name} * data)
{
{%   for mem in st.membersToFree %}
{$addIndent("    ", mem.coderCall.freeingCall(mem.coderCall))}{$loop.addNewLineIfNotLast}
{%   endfor -- st.members %}
}
{%  endfor -- structs %}
{% endif %}
{% enddef -- structSerialSource %}

{# ---------------- freeData ---------------- #}
{% def freeData(info) %}
if ({$info.name})
{
    erpc_free({$info.name});
}
{% enddef ------------------------------- freeData %}

{# ---------------- freeStruct ---------------- #}
{% def freeStruct(info) %}
{% if info.inDataContainer %}
free_{$info.typeName}_struct(&{$info.name});
{% else -- not inDataContainer %}
if ({$info.name})
{
    free_{$info.typeName}_struct({$info.name});
}
{% endif -- inDataContainer %}
{% enddef ------------------------------- freeStruct %}

{# ---------------- freeList ---------------- #}
{% def freeList(info) %}
{% if info.needFreeingCall == true %}
{$freeArray(info)}
{% endif %}
if ({$info.name})
{
    erpc_free({$info.name});
}
{% enddef ------------------------------- freeList %}

{# ---------------- freeArray ---------------- #}
{% def freeArray(info) %}
for (uint32_t {$info.forLoopCount} = 0; {$info.forLoopCount} < {$info.size}; ++{$info.forLoopCount})
{
{$addIndent("    ", info.protoNext.freeingCall(info.protoNext))}
}
{% enddef ------------------------------- freeArray %}

{# ---------------- freeUnion ---------------- #}
{% def freeUnion(info) %}
switch ({$info.dataLiteral}->{$info.discriminatorName})
{
{% for case in info.cases %}
{%  if case.needCaseFreeingCall == true %}
{%   if case.name == "default" %}
{$addIndent("    ", "default:")}
{%   else %}
{$addIndent("    ", "case ")}{% if case.name != "" %}{$case.name}{% else %}{$case.value}{% endif %}:
{%   endif -- default or case %}
    {
{%   for member in case.members %}
{%    if member.isNeedFreeingCall %}
{$addIndent("        ", member.coderCall.freeingCall(member.coderCall))}
{%    endif %}
{%   endfor -- members %}
{$addIndent("        ", "break;")}
    }
{%  endif %}
{% endfor -- cases %}
}
{% enddef ------------------------------- freeUnion %}

{# ---------------- addInfraErrorChecks---------------- #}
{% def addInfraErrorChecks(info, coderType) %}
{$> addInfraErrorChecksBegin("")}
{% if coderType == "encode" %}{$addIndent(infraErrIndents, info.encode(info))}{% else %}{$addIndent(infraErrIndents, info.decode(info))}{% endif%}
{$> addInfraErrorChecksEnd("")}
{% enddef ------------------------------- addInfraErrorChecks %}

{# ---------------- addInfraErrorChecksBegin---------------- #}
{% def addInfraErrorChecksBegin(indent) %}
{% if generateInfraErrorChecks %}{$ indent}if (!err)
{$ indent}{{% endif >%}
{% enddef ------------------------------- addInfraErrorChecksBegin %}

{# ---------------- addInfraErrorChecksEnd---------------- #}
{% def addInfraErrorChecksEnd(indent) %}
{% if generateInfraErrorChecks %}{$ indent}}{% endif >%}
{% enddef ------------------------------- addInfraErrorChecksEnd %}

{# ---------------- addInfraErrorChecksElse---------------- #}
{% def addInfraErrorChecksElse() %}
{% if generateInfraErrorChecks %}else
{
    break;
}{% endif >%}
{% enddef ------------------------------- addInfraErrorChecksElse %}
